<?php

namespace App\Http\Controllers;

use App\Models\PentestSession;
use App\Models\PentestResult;
use App\Models\DiscoveredCredential;
use App\Models\UploadBatch;
use App\Models\IpScan;
use App\Jobs\ProcessPentestSession;
use Illuminate\Http\Request;
use Illuminate\Http\JsonResponse;
use Illuminate\View\View;

class PentestController extends Controller
{
    public function selectTargets(string $batchId): View
    {
        $batch = UploadBatch::where('batch_id', $batchId)->firstOrFail();
        $onlineIps = IpScan::where('batch_id', $batchId)
            ->where('is_online', true)
            ->get();
        
        return view('pentest.select-targets', compact('batch', 'onlineIps'));
    }

    public function createSession(Request $request, string $batchId): JsonResponse
    {
        $request->validate([
            'selected_ips' => 'required|array|min:1',
            'selected_ips.*' => 'ip',
            'selected_modules' => 'required|array|min:1',
            'selected_modules.*' => 'in:web_vuln,brute_force,service_enum,exploit_test',
            'description' => 'nullable|string|max:500'
        ]);

        try {
            // Find the upload batch
            $batch = UploadBatch::where('batch_id', $batchId)->firstOrFail();
            
            $session = PentestSession::create([
                'batch_id' => $batchId,
                'selected_ips' => $request->selected_ips,
                'selected_modules' => $request->selected_modules,
                'status' => 'pending',
                'total_targets' => count($request->selected_ips) * count($request->selected_modules),
                'completed_targets' => 0,
                'description' => $request->description
            ]);

            // Dispatch the main job
            ProcessPentestSession::dispatch($session->id);

            return response()->json([
                'success' => true,
                'message' => 'Penetration testing session started',
                'session_id' => $session->id
            ]);

        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Error starting pentest session: ' . $e->getMessage()
            ], 500);
        }
    }

    public function sessionStatus(string $sessionId): JsonResponse
    {
        $session = PentestSession::where('session_id', $sessionId)->firstOrFail();
        $status = $session->status;
        if ($status === 'failed') {
            return response()->json([
                'session' => $session,
                'progress' => $session->progress,
                'status' => 'failed',
                'vulnerabilities_count' => $session->vulnerabilities_count,
                'critical_vulnerabilities_count' => $session->critical_vulnerabilities_count
            ]);
        }
        return response()->json([
            'session' => $session,
            'progress' => $session->progress,
            'status' => $status,
            'vulnerabilities_count' => $session->vulnerabilities_count,
            'critical_vulnerabilities_count' => $session->critical_vulnerabilities_count
        ]);
    }

    public function sessionResults(string $sessionId): View
    {
        $session = PentestSession::where('session_id', $sessionId)->firstOrFail();
        $results = PentestResult::where('session_id', $sessionId)
            ->orderBy('severity', 'desc')
            ->orderBy('created_at', 'desc')
            ->get();
        $credentials = DiscoveredCredential::where('session_id', $sessionId)
            ->orderBy('access_level', 'desc')
            ->get();

        return view('pentest.results', compact('session', 'results', 'credentials'));
    }

    public function listSessions(string $batchId): View
    {
        $batch = UploadBatch::where('batch_id', $batchId)->firstOrFail();
        $sessions = PentestSession::where('batch_id', $batchId)
            ->orderBy('created_at', 'desc')
            ->get();

        return view('pentest.sessions', compact('batch', 'sessions'));
    }

    public function deleteSession(string $sessionId): JsonResponse
    {
        try {
            $session = PentestSession::where('session_id', $sessionId)->firstOrFail();
            
            // Delete related records
            PentestResult::where('session_id', $sessionId)->delete();
            DiscoveredCredential::where('session_id', $sessionId)->delete();
            $session->delete();

            return response()->json([
                'success' => true,
                'message' => 'Pentest session deleted successfully'
            ]);

        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Error deleting session: ' . $e->getMessage()
            ], 500);
        }
    }

    public function sessions(): View
    {
        $sessions = PentestSession::with(['uploadBatch', 'results', 'credentials'])
            ->orderBy('created_at', 'desc')
            ->get();

        return view('pentest.sessions', compact('sessions'));
    }

    public function results($sessionId): View
    {
        $session = PentestSession::with(['results', 'credentials', 'uploadBatch'])
            ->findOrFail($sessionId);

        return view('pentest.results', compact('session'));
    }

    public function export($sessionId)
    {
        $session = PentestSession::with(['results', 'credentials', 'uploadBatch'])
            ->findOrFail($sessionId);

        $filename = "pentest_report_session_{$sessionId}_" . now()->format('Y-m-d_H-i-s') . ".csv";

        $headers = [
            'Content-Type' => 'text/csv',
            'Content-Disposition' => "attachment; filename=\"{$filename}\"",
        ];

        $callback = function() use ($session) {
            $file = fopen('php://output', 'w');
            
            // Header information
            fputcsv($file, ['Pentest Session Report']);
            fputcsv($file, ['Session ID', $session->id]);
            fputcsv($file, ['Source File', $session->uploadBatch->filename]);
            fputcsv($file, ['Status', ucfirst($session->status)]);
            fputcsv($file, ['Started', $session->created_at->format('Y-m-d H:i:s')]);
            fputcsv($file, ['Completed', $session->completed_at ? $session->completed_at->format('Y-m-d H:i:s') : 'N/A']);
            fputcsv($file, ['Target IPs', implode(', ', $session->selected_ips ?? [])]);
            fputcsv($file, ['Modules', implode(', ', $session->selected_modules ?? [])]);
            fputcsv($file, []);

            // Vulnerabilities
            fputcsv($file, ['VULNERABILITIES FOUND']);
            fputcsv($file, ['Target IP', 'Module', 'Test Name', 'Severity', 'Details']);
            
            foreach ($session->results as $result) {
                fputcsv($file, [
                    $result->ip_address,
                    $result->module_type,
                    $result->test_name,
                    $result->severity,
                    is_array($result->details) ? json_encode($result->details) : $result->details
                ]);
            }

            fputcsv($file, []);

            // Discovered credentials
            if ($session->credentials->count() > 0) {
                fputcsv($file, ['DISCOVERED CREDENTIALS']);
                fputcsv($file, ['Target IP', 'Service', 'Username', 'Password', 'Access Level']);
                
                foreach ($session->credentials as $cred) {
                    fputcsv($file, [
                        $cred->ip_address,
                        $cred->service,
                        $cred->username,
                        $cred->password,
                        $cred->access_level
                    ]);
                }
            }

            fclose($file);
        };

        return response()->stream($callback, 200, $headers);
    }

    public function cancelSession($sessionId)
    {
        try {
            $session = PentestSession::findOrFail($sessionId);
            
            if ($session->status !== 'running') {
                return response()->json([
                    'success' => false,
                    'message' => 'Session is not currently running'
                ]);
            }

            $session->update([
                'status' => 'cancelled',
                'completed_at' => now()
            ]);

            return response()->json([
                'success' => true,
                'message' => 'Session cancelled successfully'
            ]);

        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Error cancelling session: ' . $e->getMessage()
            ], 500);
        }
    }
}
